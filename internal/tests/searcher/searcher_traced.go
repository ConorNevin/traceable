// Code generated by "traceable -types Searcher -output searcher_traced.go"; DO NOT EDIT.

package searcher

import (
	"context"

	"github.com/opentracing/opentracing-go"
)

// TracedSearcher is a traced implementation of Searcher
type TracedSearcher struct {
	x Searcher
}

func (t *TracedSearcher) Many(a0 context.Context, a1 map[int]string) Errors {
	span, a0 := opentracing.StartSpanFromContext(a0, "Searcher.Many")
	defer func() {
		span.Finish()
	}()
	return t.x.Many(a0, a1)
}

func (t *TracedSearcher) One(a0 context.Context, a1 int, a2 int, a3 string) error {
	span, a0 := opentracing.StartSpanFromContext(a0, "Searcher.One")
	defer func() {
		span.Finish()
	}()
	return t.x.One(a0, a1, a2, a3)
}

func (t *TracedSearcher) Search(a0 context.Context, a1 string) error {
	span, a0 := opentracing.StartSpanFromContext(a0, "Searcher.Search")
	defer func() {
		span.Finish()
	}()
	return t.x.Search(a0, a1)
}

func (t *TracedSearcher) SearchAll(a0 context.Context, a1 ...string) (chan<- string, error) {
	span, a0 := opentracing.StartSpanFromContext(a0, "Searcher.SearchAll")
	defer func() {
		span.Finish()
	}()
	return t.x.SearchAll(a0, a1...)
}

func (t *TracedSearcher) StoreAll(a0 context.Context, a1 <-chan string) error {
	span, a0 := opentracing.StartSpanFromContext(a0, "Searcher.StoreAll")
	defer func() {
		span.Finish()
	}()
	return t.x.StoreAll(a0, a1)
}

func (t *TracedSearcher) StoreAnything(a0 context.Context, a1 interface{}) error {
	span, a0 := opentracing.StartSpanFromContext(a0, "Searcher.StoreAnything")
	defer func() {
		span.Finish()
	}()
	return t.x.StoreAnything(a0, a1)
}

func (t *TracedSearcher) StoreInterface(a0 context.Context, a1 Stringer) (int, error) {
	span, a0 := opentracing.StartSpanFromContext(a0, "Searcher.StoreInterface")
	defer func() {
		span.Finish()
	}()
	return t.x.StoreInterface(a0, a1)
}

func (t *TracedSearcher) StoreMap(a0 context.Context, a1 map[int8]string) error {
	span, a0 := opentracing.StartSpanFromContext(a0, "Searcher.StoreMap")
	defer func() {
		span.Finish()
	}()
	return t.x.StoreMap(a0, a1)
}
