package traceable

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"

	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"
)

const (
	openTracingPackagePath = "github.com/opentracing/opentracing-go"
	openTracingPackageName = "opentracing"
)

type Generator struct {
	buf        bytes.Buffer
	pkgs       map[string]*Package
	packageMap map[string]string
	parser     *parser

	RootPackage       string
	OutputPackagePath string
	Interface         Interface
}

type Package struct {
	name       string
	importPath string
	interfaces []*Interface
	imports    []*types.Package
}

func (g *Generator) Printf(format string, args ...interface{}) {
	_, _ = fmt.Fprintf(&g.buf, format, args...)
}

func (g *Generator) ParsePackage(patterns []string) {
	cfg := &packages.Config{
		Mode: packages.NeedName |
			packages.NeedTypesInfo |
			packages.NeedSyntax |
			packages.NeedTypes,
	}
	pkgs, err := packages.Load(cfg, patterns...)
	if err != nil {
		log.Fatal(err)
	}
	for _, pkg := range pkgs {
		g.addPackage(pkg)
	}
}

func (g *Generator) addPackage(pkg *packages.Package) {
	log.Printf("adding package \"%s\" (\"%s\")", pkg.Name, pkg.PkgPath)
	pp := &parser{
		imports:            make(map[string]ImportedPackage),
		importedInterfaces: make(map[string]map[string]*ast.InterfaceType),
		otherInterfaces:    make(map[string]map[string]*ast.InterfaceType),
	}

	if g.pkgs == nil {
		g.pkgs = make(map[string]*Package)
	}

	var err error
	g.pkgs[pkg.PkgPath], err = pp.parsePackage(pkg)
	if err != nil {
		log.Fatal(err)
	}

	if g.packageMap == nil {
		g.packageMap = make(map[string]string)
	}
	g.packageMap[pkg.PkgPath] = pkg.Name
	for _, i := range g.pkgs[pkg.PkgPath].imports {
		g.packageMap[i.Path()] = i.Name()
	}
}

func (g *Generator) GenerateAll(types []string) {
	for _, t := range types {
		g.Generate(t)
	}
}

func (g *Generator) Generate(typeName string) {
	log.Printf("generating for %s", typeName)

	if _, ok := g.packageMap[openTracingPackagePath]; !ok {
		g.packageMap[openTracingPackagePath] = openTracingPackageName
	}

	for _, is := range g.pkgs[g.RootPackage].interfaces {
		if is.name == typeName {
			g.Interface = *is
			break
		}
	}

	g.generate(typeName)
}

// Format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) Format() []byte {
	opts := imports.Options{
		// Since Process can add missing imports, we want to disable it since it
		// can mask errors with the generation process and import the wrong packages.
		FormatOnly: true,
		Comments:   true,
		TabIndent:  true,
		TabWidth:   8,
	}
	src, err := imports.Process("", g.buf.Bytes(), &opts)
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}

func (g *Generator) generate(typeName string) {
	g.printHeader()
	g.printImports()
	g.printStruct(typeName)
	g.printMethods(typeName)
}

func (g *Generator) printHeader() {
	g.Printf("// Code generated by \"traceable %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " "))
	g.Printf("\n")
	g.Printf("package %s", filepath.Base(g.OutputPackagePath))
	g.Printf("\n")
}

func (g *Generator) printImports() {
	if g.OutputPackagePath == "" && len(g.pkgs) == 1 {
		return
	}

	usedImports := g.Interface.imports()
	usedImports[openTracingPackagePath] = struct{}{}
	if g.OutputPackagePath != g.RootPackage {
		usedImports[g.RootPackage] = struct{}{}
	}

	g.Printf("import(\n")
	for importPath := range g.packageMap {
		if g.OutputPackagePath == importPath {
			continue
		}
		if _, ok := usedImports[importPath]; ok {
			g.Printf("\"%s\"\n", importPath)
		}
	}
	g.Printf(")\n")
}

func (g *Generator) printStruct(typeName string) {
	split := strings.Split(typeName, ".")
	structName := split[len(split)-1]
	importPath := g.importPath(typeName)

	g.Printf("// Traced%s is a traced implementation of %s\n", structName, typeName)
	g.Printf("type Traced%s struct {\n", structName)
	g.Printf("\tx ")

	if (g.OutputPackagePath != "" && len(split) == 1) && importPath != g.OutputPackagePath {
		g.Printf(g.packageMap[importPath] + ".")
	}

	g.Printf("%s\n", structName)
	g.Printf("}")
	g.Printf("\n")
}

func (g *Generator) printMethods(typeName string) {
	structName := getStructName(typeName)

	sort.Slice(g.Interface.methods, func(i, j int) bool {
		return g.Interface.methods[i].name < g.Interface.methods[j].name
	})
	for i, m := range g.Interface.methods {
		args := make([]string, len(m.args))
		argNames := make([]string, len(m.args))
		argList := make([]string, len(m.args))
		for i, a := range m.args {
			argName := "a" + strconv.Itoa(i)
			argNames[i] = argName

			var b bytes.Buffer
			if m.isVariadic && i == len(m.returns)-1 {
				b.WriteString("...")
				s, ok := a.(*types.Slice)
				if !ok {
					log.Fatal("attempting to output variadic argument but was unable to convert the type to a slice")
				}

				types.WriteType(&b, s.Elem(), g.packageName)
				argNames[i] += "..."
			} else {
				types.WriteType(&b, a, g.packageName)
			}
			args[i] = b.String()

			argList[i] = argName + " " + args[i]
		}

		returns := make([]string, len(m.returns))
		for i, r := range m.returns {
			var b bytes.Buffer
			types.WriteType(&b, r, g.packageName)
			returns[i] = b.String()
		}
		var returnStr string
		switch len(returns) {
		case 0:
		case 1:
			returnStr = returns[0]
		default:
			returnStr = "(" + strings.Join(returns, ",") + ")"
		}

		g.Printf("func (t *Traced%s) %s(%s) %s {\n", structName, m.name, strings.Join(argList, ","), returnStr)
		if m.acceptsContext() {
			g.Printf("span, %[1]s := opentracing.StartSpanFromContext(%[1]s, \"%s.%s\")\n", m.contextArg(), structName, m.name)
			g.Printf("defer func() {\n")
			g.Printf("span.Finish()\n")
			g.Printf("}()\n")
		}
		if len(m.returns) > 0 {
			g.Printf("return ")
		}
		g.Printf("t.x.%s(%s)\n", m.name, strings.Join(argNames, ","))
		g.Printf("}\n")
		if i != len(g.Interface.methods)-1 {
			g.Printf("\n")
		}
	}
}

func (g *Generator) importPath(typeName string) string {
	idx := strings.IndexRune(typeName, '.')
	if idx != -1 {
		return typeName[:idx]
	}

	// if we get here then the type is local to the package
	return g.RootPackage
}

func getStructName(typeName string) string {
	idx := strings.IndexRune(typeName, '.')
	if idx == -1 {
		return typeName
	}

	return typeName[idx+1:]
}

func (g *Generator) packageName(pkg *types.Package) string {
	if pkg == nil || g.OutputPackagePath == pkg.Path() {
		return ""
	}
	return pkg.Name()
}
