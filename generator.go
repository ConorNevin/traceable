package traceable

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"golang.org/x/tools/go/packages"
)

const (
	openTracingPackagePath = "github.com/opentracing/opentracing-go"
	openTracingPackageName = "opentracing"
)

type Generator struct {
	buf        bytes.Buffer
	pkgs       map[string]*Package
	packageMap map[string]string

	RootPackage       string
	OutputPackagePath string
	Interface         Interface
}

type Package struct {
	name       string
	importPath string
	defs       map[*ast.Ident]types.Object
	files      []*File
}

func (g *Generator) Printf(format string, args ...interface{}) {
	_, _ = fmt.Fprintf(&g.buf, format, args...)
}

func (g *Generator) ParsePackage(patterns []string) {
	cfg := &packages.Config{
		Mode: packages.NeedName |
			packages.NeedTypesInfo |
			packages.NeedSyntax |
			packages.NeedTypes,
	}
	pkgs, err := packages.Load(cfg, patterns...)
	if err != nil {
		log.Fatal(err)
	}
	for _, pkg := range pkgs {
		g.addPackage(pkg)
	}
}

func (g *Generator) addPackage(pkg *packages.Package) {
	log.Printf("adding package \"%s\" (\"%s\")", pkg.Name, pkg.PkgPath)
	p := &Package{
		name:       pkg.Name,
		importPath: pkg.PkgPath,
		defs:       pkg.TypesInfo.Defs,
		files:      make([]*File, len(pkg.Syntax)),
	}

	for i, file := range pkg.Syntax {
		p.files[i] = &File{
			file: file,
			pkg:  p,
		}
	}

	if g.pkgs == nil {
		g.pkgs = make(map[string]*Package)
	}
	g.pkgs[pkg.PkgPath] = p

	if g.packageMap == nil {
		g.packageMap = make(map[string]string)
	}
	g.packageMap[pkg.PkgPath] = pkg.Name
}

func (g *Generator) GenerateAll(types []string) {
	for _, t := range types {
		g.Generate(t)
	}
}

func (g *Generator) Generate(typeName string) {
	log.Printf("generating for %s", typeName)
	importPath := g.importPath(typeName)
	log.Printf("import path %s", importPath)

	if _, ok := g.packageMap[openTracingPackagePath]; !ok {
		g.packageMap[openTracingPackagePath] = openTracingPackageName
	}

	g.Interface = Interface{
		name:       getStructName(typeName),
		importPath: importPath,
		parser:     &parser{imports: make(map[string]ImportedPackage)},
	}
	for _, p := range g.pkgs {
		if p.importPath != importPath {
			continue
		}

		for _, file := range p.files {
			if err := g.Interface.parser.parseImports(file.file); err != nil {
				log.Fatal(err)
			}
			// Set the state for this run of the walker.
			if file.file != nil {
				ast.Inspect(file.file, g.Interface.findInterfaces)
			}

			for _, is := range g.Interface.parser.imports {
				g.packageMap[is.Path] = is.Name
			}
		}
	}

	g.printHeader()
	g.printImports()
	g.printStruct(typeName)
	g.printMethods(typeName)
}

// Format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) Format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}

func (g *Generator) printHeader() {
	g.Printf("// Code generated by \"traceable %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " "))
	g.Printf("\n")
	g.Printf("package %s", filepath.Base(g.OutputPackagePath))
	g.Printf("\n")
}

func (g *Generator) printImports() {
	if g.OutputPackagePath == "" && len(g.pkgs) == 1 {
		return
	}

	g.Printf("import(\n")
	for importPath := range g.packageMap {
		if g.OutputPackagePath == importPath {
			continue
		}

		g.Printf("\"%s\"\n", importPath)
	}
	g.Printf(")\n")
}

func (g *Generator) printStruct(typeName string) {
	split := strings.Split(typeName, ".")
	structName := split[len(split)-1]
	importPath := g.importPath(typeName)

	g.Printf("// Traced%s is a traced implementation of %s\n", structName, typeName)
	g.Printf("type Traced%s struct {\n", structName)
	g.Printf("\tx ")

	log.Printf("import path: %s, output path: %s", importPath, g.OutputPackagePath)

	if (g.OutputPackagePath != "" && len(split) == 1) && importPath != g.OutputPackagePath {
		g.Printf(g.packageMap[importPath] + ".")
	}

	g.Printf("%s\n", structName)
	g.Printf("}")
	g.Printf("\n")
}

func (g *Generator) printMethods(typeName string) {
	structName := getStructName(typeName)
	for _, m := range g.Interface.methods {
		args := make([]string, len(m.args))
		argNames := make([]string, len(m.args))
		argList := make([]string, len(m.args))
		for i, a := range m.args {
			args[i] = a.String()
			argNames[i] = "a" + strconv.Itoa(i)
			argList[i] = argNames[i] + " " + args[i]
		}

		returns := make([]string, len(m.returns))
		for i, r := range m.returns {
			returns[i] = r.String()
		}
		var returnStr string
		switch len(returns) {
		case 0:
		case 1:
			returnStr = returns[0]
		default:
			returnStr = "(" + strings.Join(returns, ",") + ")"
		}

		g.Printf("func (t *Traced%s) %s(%s) %s {\n", structName, m.name, strings.Join(argList, ","), returnStr)
		if m.acceptsContext() {
			g.Printf("span, %[1]s := opentracing.StartSpanFromContext(%[1]s, \"%s.%s\")\n", m.contextArg(), structName, m.name)
			g.Printf("defer func() {\n")
			g.Printf("span.Finish()\n")
			g.Printf("}()\n")
		}
		if len(m.returns) > 0 {
			g.Printf("return ")
		}
		g.Printf("t.x.%s(%s)\n", m.name, strings.Join(argNames, ","))
		g.Printf("}\n")
	}
}

func (g *Generator) importPath(typeName string) string {
	idx := strings.IndexRune(typeName, '.')
	if idx != -1 {
		return typeName[:idx]
	}

	// if we get here then the type is local to the package
	return g.RootPackage
}

func getStructName(typeName string) string {
	idx := strings.IndexRune(typeName, '.')
	if idx == -1 {
		return typeName
	}

	return typeName[idx+1:]
}
